export const ToolingFrame = ({ imageURL, caption, imageName, maxWidth = '3000px', maxHeight = '3000px' }) => {
    const [showLightbox, setShowLightbox] = React.useState(false);
    const imgRef = React.useRef(null);
    const [isDragging, setIsDragging] = React.useState(false);
    const [position, setPosition] = React.useState({ x: 0, y: 0 });
    const [dragStart, setDragStart] = React.useState({ x: 0, y: 0 });
    const containerRef = React.useRef(null);
    const [imageLoaded, setImageLoaded] = React.useState(false);
    const [imageDimensions, setImageDimensions] = React.useState({ width: 0, height: 0 });
    const [containerDimensions, setContainerDimensions] = React.useState({ width: '100%', height: '100%' });
    const [scale, setScale] = React.useState(1);
    const [initialDistance, setInitialDistance] = React.useState(0);
    const [isZooming, setIsZooming] = React.useState(false);
    const minScale = 1;
    const maxScale = 5;
    const zoomStep = 0.2;

    const handleDownload = async (e) => {
        e.preventDefault();
        e.stopPropagation();
        try {
            const response = await fetch(imageURL);
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = imageName || 'image.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(url);
        } catch (error) {
            console.error('Download failed:', error);
        }
    };

    const handleImageClick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setShowLightbox(true);
    };

    const closeLightbox = () => {
        setShowLightbox(false);
        setPosition({ x: 0, y: 0 });
        setScale(1);
        setImageLoaded(false);
        setImageDimensions({ width: 0, height: 0 });
        setContainerDimensions({ width: '100%', height: '100%' });
    };

    const handleMouseDown = (e) => {
        setIsDragging(true);
        setDragStart({ 
            x: e.clientX - position.x, 
            y: e.clientY - position.y 
        });
    };

    const handleMouseMove = (e) => {
        if (!isDragging || !containerRef.current) return;
        
        let newX = e.clientX - dragStart.x;
        let newY = e.clientY - dragStart.y;
        
        if (imageDimensions.width && imageDimensions.height) {
            const containerWidth = containerRef.current.offsetWidth;
            const containerHeight = containerRef.current.offsetHeight;
            const imgWidth = imageDimensions.width * scale;
            const imgHeight = imageDimensions.height * scale;
            
            const isWider = (imgWidth - containerWidth) >= 1;
            const isTaller = (imgHeight - containerHeight) >= 1;
            
            if (isWider) {
                const halfOverflowX = (imgWidth - containerWidth) / 2;
                newX = Math.min(Math.max(newX, -halfOverflowX), halfOverflowX);
            } else {
                newX = 0;
            }
            
            if (isTaller) {
                const halfOverflowY = (imgHeight - containerHeight) / 2;
                newY = Math.min(Math.max(newY, -halfOverflowY), halfOverflowY);
            } else {
                newY = 0;
            }
        }
        
        setPosition({
            x: newX,
            y: newY
        });
    };

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    const handleZoom = (newScale, centerX, centerY) => {
        if (!containerRef.current || !imageDimensions.width || !imageDimensions.height) return;
        
        const boundedScale = Math.max(minScale, Math.min(maxScale, newScale));
        let newX = position.x;
        let newY = position.y;
        
        if (centerX !== undefined && centerY !== undefined) {
            const rect = containerRef.current.getBoundingClientRect();
            const offsetX = centerX - rect.left - rect.width / 2;
            const offsetY = centerY - rect.top - rect.height / 2;
            
            const scaleRatio = boundedScale / scale;
            newX = position.x - offsetX * (scaleRatio - 1);
            newY = position.y - offsetY * (scaleRatio - 1);
        }
        
        const containerWidth = containerRef.current.offsetWidth;
        const containerHeight = containerRef.current.offsetHeight;
        const imgWidth = imageDimensions.width * boundedScale;
        const imgHeight = imageDimensions.height * boundedScale;
        
        const isWiderThanContainer = (imgWidth - containerWidth) >= 1;
        const isTallerThanContainer = (imgHeight - containerHeight) >= 1;
        
        if (isWiderThanContainer) {
            const maxX = (imgWidth - containerWidth) / 2;
            const minX = -maxX;
            newX = Math.min(Math.max(newX, minX), maxX);
        } else {
            newX = 0;
        }
        
        if (isTallerThanContainer) {
            const maxY = (imgHeight - containerHeight) / 2;
            const minY = -maxY;
            newY = Math.min(Math.max(newY, minY), maxY);
        } else {
            newY = 0;
        }
        
        setPosition({ x: newX, y: newY });
        setScale(boundedScale);
    };

    const zoomIn = () => {
        handleZoom(scale + zoomStep);
    };

    const zoomOut = () => {
        handleZoom(scale - zoomStep);
    };

    const resetTransform = () => {
        setScale(1);
        setPosition({ x: 0, y: 0 });
    };

    const handleWheel = (e) => {
        e.preventDefault();
        const delta = -e.deltaY * 0.001;
        const newScale = scale + delta;
        handleZoom(newScale, e.clientX, e.clientY);
    };

    const getTouchDistance = (touches) => {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    };

    const handleTouchStart = (e) => {
        if (e.touches.length === 2) {
            e.preventDefault();
            setIsZooming(true);
            setInitialDistance(getTouchDistance(e.touches));
        } else if (e.touches.length === 1) {
            setIsDragging(true);
            setDragStart({
                x: e.touches[0].clientX - position.x,
                y: e.touches[0].clientY - position.y
            });
        }
    };

    const handleTouchMove = (e) => {
        if (e.touches.length === 2 && isZooming) {
            e.preventDefault();
            const currentDistance = getTouchDistance(e.touches);
            const scaleDelta = currentDistance / initialDistance;
            const newScale = scale * scaleDelta;
            
            const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            
            handleZoom(newScale, centerX, centerY);
            setInitialDistance(currentDistance);
        } else if (e.touches.length === 1 && isDragging && containerRef.current) {
            let newX = e.touches[0].clientX - dragStart.x;
            let newY = e.touches[0].clientY - dragStart.y;
            
            if (imageDimensions.width && imageDimensions.height) {
                const containerWidth = containerRef.current.offsetWidth;
                const containerHeight = containerRef.current.offsetHeight;
                const imgWidth = imageDimensions.width * scale;
                const imgHeight = imageDimensions.height * scale;
                
                const isWider = (imgWidth - containerWidth) >= 1;
                const isTaller = (imgHeight - containerHeight) >= 1;
                
                if (isWider) {
                    const halfOverflowX = (imgWidth - containerWidth) / 2;
                    newX = Math.min(Math.max(newX, -halfOverflowX), halfOverflowX);
                } else {
                    newX = 0;
                }
                
                if (isTaller) {
                    const halfOverflowY = (imgHeight - containerHeight) / 2;
                    newY = Math.min(Math.max(newY, -halfOverflowY), halfOverflowY);
                } else {
                    newY = 0;
                }
            }
            
            setPosition({ x: newX, y: newY });
        }
    };

    const handleTouchEnd = (e) => {
        if (e.touches.length < 2) {
            setIsZooming(false);
        }
        if (e.touches.length === 0) {
            setIsDragging(false);
        }
    };

    React.useEffect(() => {
        const handleEscape = (e) => {
            if (e.key === 'Escape' && showLightbox) {
                closeLightbox();
            }
        };

        if (showLightbox) {
            document.addEventListener('keydown', handleEscape);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }

        return () => {
            document.removeEventListener('keydown', handleEscape);
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [showLightbox, isDragging, position, dragStart, scale, imageDimensions]);

    return (
        <>
            <div className="flex flex-col">
                <div onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }}>
                    <Frame caption={caption}>
                        <div 
                            onClick={handleImageClick}
                            className="cursor-zoom-in"
                            style={{ display: 'block', position: 'relative' }}
                        >
                            <img 
                                ref={imgRef}
                                src={imageURL} 
                                alt={imageName || caption} 
                                className="w-full h-auto"
                                style={{ pointerEvents: 'none' }}
                            />
                        </div>
                    </Frame>
                </div>
                <div className="flex justify-end my-2">
                    <Tooltip tip="Download image">
                        <button
                            onClick={handleDownload}
                            className="bg-white text-black text-xs px-3 py-2 rounded-md border border-gray-300 hover:bg-gray-100 transition-all cursor-pointer"
                        >
                            <Icon icon="arrow-down-to-line" iconType="regular" color="black"/> 
                        </button>
                    </Tooltip>
                </div>
            </div>

            {showLightbox && (
                <div 
                    style={{
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        backgroundColor: 'rgba(0, 0, 0, 0.95)',
                        zIndex: 999999,
                        display: 'flex',
                        alignItems: 'center',
                        cursor: 'default',
                        justifyContent: 'center',
                        padding: '50px'
                    }}
                >

                    
                    <div
                        ref={containerRef}
                        style={{
                            position: 'relative',
                            width: containerDimensions.width,
                            height: containerDimensions.height,
                            maxWidth: '100%',
                            maxHeight: '100%',
                            overflow: 'hidden',
                            cursor: imageLoaded ? (isDragging ? 'grabbing' : 'grab') : 'wait',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            borderRadius: '15px',
                            border: '2px solid rgba(255, 255, 255, 0.3)'
                        }}
                        onMouseDown={handleMouseDown}
                        onWheel={handleWheel}
                        onTouchStart={handleTouchStart}
                        onTouchMove={handleTouchMove}
                        onTouchEnd={handleTouchEnd}
                    >
                        <div style={{ position: 'absolute', left: '20px', top: '20px', zIndex: 1000000, backgroundColor: 'rgba(36, 36, 36, 0.76)', padding: '10px', borderRadius: '15px', border: '1px solid rgba(255, 255, 255, 0.3)', pointerEvents: 'none'  }}>
                                <p style={{ fontSize: '16px', fontWeight: 'bold', color: 'white', marginLeft: '10px' }}>{caption}</p>
                        </div>
                        <button
                            onClick={closeLightbox}
                            onMouseDown={(e) => e.stopPropagation()}
                            style={{
                                position: 'absolute',
                                top: '20px',
                                right: '20px',
                                background: 'rgba(36, 36, 36, 0.76)',
                                border: '1px solid rgba(255, 255, 255, 0.3)',
                                color: 'white',
                                fontSize: '24px',
                                width: '40px',
                                height: '40px',
                                borderRadius: '50%',
                                cursor: 'pointer',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                transition: 'background 0.2s',
                                zIndex: 1000000
                            }}
                            onMouseEnter={(e) => { e.target.style.background = 'rgba(36, 36, 36, 0.9)'; }}
                            onMouseLeave={(e) => { e.target.style.background = 'rgba(36, 36, 36, 0.76)'; }}
                        >
                            ×
                        </button>
                        <div 
                            style={{
                                position: 'absolute',
                                bottom: '20px',
                                left: '20px',
                                display: 'flex',
                                gap: '10px',
                                zIndex: 1000000
                            }}
                        >
                            <button
                                onClick={(e) => { e.stopPropagation(); zoomIn(); }}
                                onMouseDown={(e) => e.stopPropagation()}
                                disabled={scale >= maxScale}
                                style={{
                                    background: 'rgba(36, 36, 36, 0.76)',
                                    border: '1px solid rgba(255, 255, 255, 0.3)',
                                    color: 'white',
                                    fontSize: '20px',
                                    width: '40px',
                                    height: '40px',
                                    borderRadius: '8px',
                                    cursor: scale >= maxScale ? 'not-allowed' : 'pointer',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    transition: 'background 0.2s',
                                    opacity: scale >= maxScale ? 0.5 : 1
                                }}
                                onMouseEnter={(e) => { if (scale !== maxScale) e.target.style.background = 'rgba(36, 36, 36, 0.9)'; }}
                                onMouseLeave={(e) => { e.target.style.background = 'rgba(36, 36, 36, 0.76)'; }}
                            >
                                +
                            </button>
                            <button
                                onClick={(e) => { e.stopPropagation(); zoomOut(); }}
                                onMouseDown={(e) => e.stopPropagation()}
                                disabled={scale <= minScale}
                                style={{
                                    background: 'rgba(36, 36, 36, 0.76)',
                                    border: '1px solid rgba(255, 255, 255, 0.3)',
                                    color: 'white',
                                    fontSize: '20px',
                                    width: '40px',
                                    height: '40px',
                                    borderRadius: '8px',
                                    cursor: scale <= minScale ? 'not-allowed' : 'pointer',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    transition: 'background 0.2s',
                                    opacity: scale <= minScale ? 0.5 : 1
                                }}
                                onMouseEnter={(e) => { if (scale !== minScale) e.target.style.background = 'rgba(36, 36, 36, 0.9)'; }}
                                onMouseLeave={(e) => { e.target.style.background = 'rgba(36, 36, 36, 0.76)'; }}
                            >
                                −
                            </button>
                            <button
                                onClick={(e) => { e.stopPropagation(); resetTransform(); }}
                                onMouseDown={(e) => e.stopPropagation()}
                                disabled={scale === 1 && position.x === 0 && position.y === 0}
                                style={{
                                    background: 'rgba(36, 36, 36, 0.76)',
                                    border: '1px solid rgba(255, 255, 255, 0.3)',
                                    color: 'white',
                                    fontSize: '16px',
                                    width: '40px',
                                    height: '40px',
                                    borderRadius: '8px',
                                    cursor: (scale === 1 && position.x === 0 && position.y === 0) ? 'not-allowed' : 'pointer',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    transition: 'background 0.2s',
                                    opacity: (scale === 1 && position.x === 0 && position.y === 0) ? 0.5 : 1
                                }}
                                onMouseEnter={(e) => { if (scale !== 1 || position.x !== 0 || position.y !== 0) e.target.style.background = 'rgba(36, 36, 36, 0.9)'; }}
                                onMouseLeave={(e) => { e.target.style.background = 'rgba(36, 36, 36, 0.76)'; }}
                            >
                                ⟲
                            </button>
                            <div 
                                style={{
                                    background: 'rgba(36, 36, 36, 0.76)',
                                    border: '1px solid rgba(255, 255, 255, 0.3)',
                                    color: 'white',
                                    fontSize: '14px',
                                    padding: '0 12px',
                                    height: '40px',
                                    borderRadius: '8px',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    minWidth: '60px',
                                    pointerEvents: 'none'
                                }}
                            >
                                {Math.round(scale * 100)}%
                            </div>
                        </div>
                        <div style={{ position: 'absolute', right: '20px', bottom: '20px', zIndex: 1000000, backgroundColor: 'rgba(36, 36, 36, 0.76)', padding: '10px 15px', borderRadius: '15px', border: '1px solid rgba(255, 255, 255, 0.3)', pointerEvents: 'none'  }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px'}}>
                            <Icon icon="hand" iconType="regular" color="white"/>
                                <p style={{ fontSize: '12px', color: 'white', margin: 0 }}>Drag to move image</p>
                            </div>
                        </div>
                        <div
                            style={{
                                position: 'relative',
                                transform: `translate(${position.x}px, ${position.y}px) scale(${scale})`,
                                transition: isDragging || isZooming ? 'none' : 'transform 0.2s ease-out'
                            }}
                        >
                            <img 
                                src={imageURL}
                                alt={imageName || caption}
                                onLoad={(e) => {
                                    const imgWidth = e.target.offsetWidth;
                                    const imgHeight = e.target.offsetHeight;
                                    
                                    setImageDimensions({
                                        width: imgWidth,
                                        height: imgHeight
                                    });
                                    
                                    if (containerRef.current) {
                                        const availableWidth = containerRef.current.offsetWidth;
                                        const availableHeight = containerRef.current.offsetHeight;
                                        
                                        const newWidth = imgWidth < availableWidth ? imgWidth + 'px' : '100%';
                                        const newHeight = imgHeight < availableHeight ? imgHeight + 'px' : '100%';
                                        
                                        setContainerDimensions({
                                            width: newWidth,
                                            height: newHeight
                                        });
                                    }
                                    
                                    setTimeout(() => setImageLoaded(true), 500);
                                }}
                                style={{
                                    display: 'block',
                                    width: 'auto',
                                    height: 'auto',
                                    maxWidth: '100%',
                                    maxHeight: '100%',
                                    boxShadow: '0 0 50px rgba(0, 0, 0, 0.5)',
                                    pointerEvents: 'none',
                                    userSelect: 'none'
                                }}
                            />
                        </div>
                    </div>
                </div>
            )}
        </>
    );

};

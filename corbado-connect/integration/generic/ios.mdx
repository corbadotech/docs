---
title: "iOS Native App Integration with Corbado Connect"
description: "Learn how to integrate passkey authentication into your native iOS app using the Corbado iOS SDK. This guide covers setup, passkey enrollment, login, and management."
sidebarTitle: "iOS Native App"
---

TODO Link code snippets to GitHub files (example app)?
TODO Explain that example app uses Cognito but all "cases" are the same
TODO Exchange pngs

## Introduction

**Corbado Connect** provides a native iOS SDK that simplifies the integration of passkey authentication into your iOS native apps. By using our SDK, you can offer a seamless and secure user experience with passkeys, without needing to replace your existing Identity Provider (IdP). The SDK handles the complexities of the WebAuthn standard and our backend APIs, allowing you to focus on your app's core functionality.

This guide provides a step-by-step approach to integrating the **Corbado iOS SDK**. You'll learn how to implement passkey enrollment, login, and management within your app.

For a complete, working example, please refer to our example app available on GitHub. It's a great resource to see the SDK in action and to use as a reference during your own implementation.

<Card title="Example App" href="https://github.com/corbado/corbado-ios/tree/main/ConnectExample">
  See the Corbado iOS SDK in action.
</Card>

## SDK Installation

For the most up-to-date instructions on requirements, installation, and initialization, please refer to the official `README` in our GitHub repository. The `README` provides a comprehensive guide to getting the SDK set up in your project.

<Card title="Corbado iOS SDK" href="https://github.com/corbado/corbado-ios">
  Learn how to install the Corbado iOS SDK.
</Card>

## Backend Integration

The backend logic required to support **Corbado Connect** is consistent across all client platforms, whether it's a web application, an iOS native app, or an Android native app.

To maintain a single source of truth and avoid duplicating instructions, we've consolidated all backend-related steps into a dedicated guide. Please refer to it for a complete walkthrough of the required API endpoints in your backend:

<Card title="Backend Setup" href="/corbado-connect/integration/generic/backend">
  Learn how to implement the necessary backend endpoints in your backend to support passkey operations.
</Card>

To call your endpoints for `connectToken` generation and `signedPasskeyData` verification, we create a small helper class that will be utilized in the upcoming integrations:

```swift AppBackend.swift
class AppBackend {
    /// Get connectToken from backend (which gets it from Corbado Backend API)
    static func getConnectToken(connectTokenType: ConnectTokenType, sessionId: String) async throws -> String {
        // 1. Set up request
        let urlString = "https://<your-backend-url>/auth/createConnectToken"
        guard let url = URL(string: urlString) else {
            throw URLError(.badURL)
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        let requestPayload = GetConnectTokenRequest(
            connectTokenType: connectTokenType.rawValue,
            sessionId: sessionId
        )
        
        do {
            let jsonData = try JSONEncoder().encode(requestPayload)
            request.httpBody = jsonData
        } catch {
            throw error
        }

        // 2. Perform request
        let (data, response) = try await URLSession.shared.data(for: request)

        // 3. Check response
        guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {
            let statusCode = (response as? HTTPURLResponse)?.statusCode ?? -1
            print("Error: HTTP Status Code \(statusCode)")
            
            // You might want to try decoding error details from 'data' here if your API
            // provides them or a custom error
            throw URLError(.badServerResponse)
        }

        // 4. Decode the JSON response
        do {
            let decodedResponse = try JSONDecoder().decode(GetConnectTokenResponse.self, from: data)
            return decodedResponse.token
        } catch {
            print("Error decoding JSON response: \(error)")
            
            if let responseString = String(data: data, encoding: .utf8) {
                print("Raw response string: \(responseString)")
            }
            
            throw error
        }
    }

    /// Verify signedPasskeyData with backend (which verifies with Corbado Backend API)
    static func verifySignedPasskeyData(signedPasskeyData: String) async throws -> (Bool, String) {
        // 1. Set up request
        let urlString = "https://<your-backend>/auth/verifySignedPasskeyData"
        guard let url = URL(string: urlString) else {
            throw URLError(.badURL)
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        let requestPayload = VerifySignedPasskeyDataRequest(
            signedPasskeyData: signedPasskeyData
        )
        
        do {
            let jsonData = try JSONEncoder().encode(requestPayload)
            request.httpBody = jsonData
        } catch {
            throw error
        }

        // 2. Perform request
        let (data, response) = try await URLSession.shared.data(for: request)

        // 3. Check response
        guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {
            let statusCode = (response as? HTTPURLResponse)?.statusCode ?? -1
            print("Error: HTTP Status Code \(statusCode)")
            
            // You might want to try decoding error details from 'data' here if your API
            // provides them or a custom error
            throw URLError(.badServerResponse)
        }

        // 4. Decode the JSON response
        do {
            let decodedResponse = try JSONDecoder().decode(VerifySignedPasskeyDataResponse.self, from: data)
            return (decodedResponse.success, decodedResponse.sessionId)
        } catch {
            print("Error decoding JSON response: \(error)")
            
            if let responseString = String(data: data, encoding: .utf8) {
                print("Raw response string: \(responseString)")
            }
            
            throw error
        }
    }
}

struct GetConnectTokenRequest: Codable {
    let connectTokenType: String
    let idToken: String
}

struct GetConnectTokenResponse: Codable {
    let token: String
}

struct VerifySignedPasskeyDataRequest: Codable {
    let signedPasskeyData: String
}

struct VerifySignedPasskeyDataResponse: Codable {
    let success: Bool
    let sessionId: String
}
```

For `getConnectToken()`, you must provide the `sessionId` of the user's session to enable the backend to verify the user's authenticated state.

<Info>We use a `sessionId` for demonstration purposes only. Any other method, such as a JWT, would also be suitable.</Info>

## Step 1: Passkey Enrollment

In a typical integration scenario, the initial user sign-up is handled through your existing authentication system's standard registration process. This could be through:

- Email and password registration
- Social login providers
- Enterprise SSO

Once a user has successfully created an account and is logged in, **Corbado Connect** provides the ability to add a passkey to their account for future passwordless logins. This process is often called "passkey append" and represents the bridge between your existing user management system and Corbado's passkey infrastructure.

This approach offers several advantages:

- Maintains compatibility with your existing user registration flow
- Allows for gradual adoption of passkeys
- Preserves existing user data and relationships
- Enables a smooth transition for your users

The complete user sign-up and passkey append flow is illustrated in detail in our [User Sign-up Flow documentation](/corbado-connect/flows/user-sign-up). In the following sections, we'll break down each component of the implementation.

### Implementation Overview

The user sign-up and passkey append process consists of a series of coordinated interactions between your iOS native app and backend, your authentication system, and Corbado's APIs. Here's a high-level overview of the flow:

```mermaid
sequenceDiagram
    autonumber
    participant App as Your<br/>iOS Native App
    participant Backend as Your<br/>Backend
    participant IdP as Your<br/>Auth System
    participant FAPI as Corbado<br/>Frontend API
    participant BAPI as Corbado<br/>Backend API
    participant Actions as Corbado<br/>Actions

    Note over App: Corbado iOS SDK
    App->>+Backend: POST /auth/createConnectToken
    Backend->>Backend: Verify user session
    Backend->>+BAPI: POST /v2/connectTokens
    BAPI-->>-Backend: Return ConnectToken
    Backend-->>-App: Return ConnectToken

    App->>+FAPI: Execute passkey ceremony (WebAuthn)
    Note over App: Corbado iOS SDK<br/>handles passkey creation
    FAPI->>+Actions: Execute post-append action
    Actions->>+IdP: Set user preferences/flags
    IdP-->>-Actions: Return success
    Actions-->>-FAPI: Return success
    FAPI-->>-App: Return success
```

In the following sections, we will explain each step in detail.

### App Integration

Integrating passkey enrollment into your app involves presenting a new screen that encourages authenticated users to create a passkey for future passwordless logins.

![Passkey creation screen](/images/corbado-connect/mobile/passkey-append.png)

The interaction with the **Corbado iOS SDK** on this screen occurs at two key moments: before the screen is rendered and when the user taps the creation button.

#### Before Rendering

Before rendering the passkey enrollment screen, you should call the `isAppendAllowed()` method from the **Corbado iOS SDK**. This function is crucial for determining if the current user is eligible to add a passkey, based on your configurations for [Gradual Rollout](/corbado-connect/features/gradual-rollout) and [Passkey Intelligence](/corbado-connect/features/passkey-intelligence).

The method requires a `connectTokenProvider`, a closure that fetches a short-lived `connectToken` from your backend. We'll use the `AppBackend` helper class defined previously. You need to provide the user's current session identifier (e.g., a session ID or JWT) so your backend can verify their authenticated state before generating the token.

```swift
// In your ViewModel or screen logic
let nextStep = await corbado.isAppendAllowed { _ in
    // Provide the session ID of the currently logged-in user.
    return try await AppBackend.getConnectToken(connectTokenType: .append, sessionId: "your-user-session-id")
}

switch nextStep {
case .askUserForAppend(let autoAppend, _):
    if autoAppend {
        // Passkey Intelligence determined the user is highly likely to convert.
        // You can immediately trigger the passkey creation ceremony or adjust the UI
        // to encourage immediate action. For now, we'll simply show the screen.
    }
    
    // Render the screen as shown above, allowing the user to initiate.
case .skip:
    // The user is not eligible for passkey append at this time.
    // You should skip this screen and navigate them to the main part of your app.
}
```

#### On Button Click

When the user taps the button to create a passkey, you must call the `completeAppend()` method from the **Corbado iOS SDK**. This function initiates the native iOS passkey creation ceremony, which securely interacts with the device's hardware and Corbado's backend.

The method returns a status indicating the outcome of the ceremony, which you should handle accordingly.

```swift
// In your button's action handler
let response = await corbado.completeAppend()

switch response {
case .completed:
    // Success! The passkey was created and associated with the user's account.
    // Navigate to a success screen or the next part of your app.
    print("Passkey creation successful!")
case .cancelled:
    // The user manually cancelled the native iOS prompt.
    // No action is typically needed; the user remains on the current screen.
    print("Passkey creation was cancelled by the user.")
case .excludeCredentialsMatch:
    // A passkey from this device already exists for the user.
    // This is not an error. Inform the user gracefully.
    print("A passkey already exists on this device.")
case .error:
    // An unexpected error occurred during the process.
    // Display an error message to the user.
    print("An error occurred during passkey creation.")
}
```

## Step 2: Passkey Login

Now that users can associate passkeys with their accounts, we can enable a truly passwordless login experience. The goal is to authenticate a user with their passkey using **Corbado Connect** and, upon successful verification, establish an authenticated session in your system.

The complete flow is illustrated in detail in our [User Login Flow documentation](/corbado-connect/flows/user-login).

### Implementation Overview

The user login process consists of a series of coordinated interactions between your iOS native app and backend, your authentication system, and Corbado's APIs. Here's a high-level overview of the flow:

```mermaid
sequenceDiagram
    autonumber
    participant App as Your<br/>iOS Native App
    participant Backend as Your<br/>Backend
    participant IdP as Your<br/>Auth System
    participant FAPI as Corbado<br/>Frontend API
    participant BAPI as Corbado<br/>Backend API
    participant Actions as Corbado<br/>Actions

    App->>+FAPI: Execute passkey ceremony (WebAuthn)
    Note over App: Corbado iOS SDK<br/>handles passkey login
    FAPI->>+Actions: Execute pre-login action
    Actions->>+IdP: User lookup by email
    IdP-->>-Actions: Return user ID
    Actions-->>-FAPI: Return user ID
    FAPI->>FAPI: Verify passkey login
    FAPI-->>-App: Return signedPasskeyData

    App->>+Backend: POST /auth/verifySignedPasskeyData<br/>(signedPasskeyData)
    Backend->>+BAPI: POST /v2/passkeys/verifySignedData
    BAPI-->>-Backend: Return verification result
    Backend->>+IdP: Create user session
    IdP-->>-Backend: Return session ID
    Backend-->>-App: Return session ID
```

In the following sections, we will explain each step in detail.

### App Integration

Integrating passkey login into your app is slightly more complex than passkey enrollment because it requires direct integration with your existing login screen and involves handling several different cases and potential UI states across multiple screens.

#### Before Rendering

Before rendering the login screen, you should call the `isLoginAllowed()` method from the **Corbado iOS SDK**. This function is crucial for determining if the current user is eligible to use a passkey, based on your configurations for [Gradual Rollout](/corbado-connect/features/gradual-rollout) and [Passkey Intelligence](/corbado-connect/features/passkey-intelligence).

```swift
let nextStep = await corbado.isLoginAllowed()
switch nextStep {
case .initTextField(let cuiChallenge, _):
    // If cuiChallenge is not nil, handle "Conditional UI Login",
    // otherwise handle "Textfield Login" (see below)
    
case .initOneTap(let email):
    // Handle "OneTap Login" (see below)
case .initFallback(_, _):
    // Handle "Fallback Login" (see below)
}
```

#### Conditional UI Login

![Conditional Login](/images/corbado-connect/mobile/passkey-login-cui.png)

With [Conditional UI](https://www.corbado.com/glossary/conditional-ui), a user can log in with an existing passkey without providing their login identifier (e.g., email). The passkey prompt appears automatically. To handle this case, you need to call the `loginWithoutIdentifier()` method from the **Corbado iOS SDK**.

If the login has been successful (`.done`), you must verify the returned `signedPasskeyData` with your backend using the helper method `verifySignedPasskeyData()` implemented earlier.

```swift
// Take cuiChallenge from .initTextField(), see above
let nextStep = await corbado.loginWithoutIdentifier(cuiChallenge: cuiChallenge, conditionalUI: false) {
    // This closure is called when the Corbado iOS SDK is waiting for a user interaction.
    // You can use it to show a loading indicator.
}

switch nextStep {
case .done(let signedPasskeyData, let username):
    // The passkey ceremony was successful.
    do {
        let (success, sessionId) = try await AppBackend.verifySignedPasskeyData(signedPasskeyData: signedPasskeyData)
        if success {
            // Backend verification successful. Create a session using the returned 
            // session ID and navigate the user to the logged-in area of your app.
        } else {
            // Backend verification failed. Show an appropriate error message.
        }
    } catch (let error) {
        // Handle error
    }
    
case .ignore(_):
    // You could start CUI here (TODO ???)
    
case .initSilentFallback(let email, _):
    // Passkey login failed silently, and a fallback is configured. The user
    // should now proceed with a different authentication method on your
    // fallback login screen.
    
case .error(let error, let triggerFallback, _, let username):
    if triggerFallback {
        // A fallback has been triggered due to an error.
        // Redirect to your fallback login screen.
    }
        
    switch error {
    case .PasskeyDeletedOnServer(let message):
        // This passkey still exists on the device but was deleted 
        // from the server. Inform the user about this situation.
    default:
        // A generic error occurred. Show a generic error message.
    }
}
```

#### Textfield Login

![Textfield Login](/images/corbado-connect/mobile/passkey-login-textfield.png)

This is the standard identifier-first login flow. The user provides their login identifier (e.g., email), and your app uses it to initiate the passkey ceremony. To handle this case, you call the `loginWithIdentifier()` method from the **Corbado iOS SDK**.

Just like with other flows, a successful login returns `.done` with `signedPasskeyData`, which you must verify with your backend.

```swift
// Take email from textfield input
let nextStep = await corbado.loginWithIdentifier(identifier: email)

switch nextStep {
case .done(let signedPasskeyData, let username):
    // The passkey ceremony was successful.
    do {
        let (success, sessionId) = try await AppBackend.verifySignedPasskeyData(signedPasskeyData: signedPasskeyData)
        if success {
            // Backend verification successful. Create a session using the returned 
            // session ID and navigate the user to the logged-in area of your app.
        } else {
            // Backend verification failed. Show an error message.
        }
    } catch (let error) {
        // Handle error
    }
case .initSilentFallback(let email, _):
    // A fallback is configured. Route to your fallback login screen.
    
case .error(let error, let triggerFallback, _, let username):
    if triggerFallback {
        // A fallback has been triggered. Route to your fallback login screen.
    }
    
    switch error {
    case .UserNotFound:
        // No user account matches the provided identifier.
        // Show an error message like "There is no account registered to that email address."
    default:
        // A generic error occurred.
    }
    
case .initRetry:
    // The operation can be retried. You might want to show a retry button to the user.
}
```

#### OneTap Login

![OneTap Login](/images/corbado-connect/mobile/passkey-login-onetap.png)

[One-Tap Login](/corbado-connect/features/one-tap-login) offers the most frictionless experience. When the **Corbado iOS SDK** has a stored identifier for the user, it can initiate the passkey login with a single tap, skipping the need for the user to type anything. You handle this case by calling `loginWithOneTap()`.

The subsequent steps for handling the response are identical to the **Textfield Login** flow: you will need to handle the different cases returned by the method and ultimately verify the `signedPasskeyData` with your backend.

```swift
let nextStep = await corbado.loginWithOneTap()

// Handle the 'nextStep' response just as you would for the 'Textfield Login'
// flow. The possible cases (.done, .error, etc.) are the same.
```

#### Fallback Login

![Fallback Login](/images/corbado-connect/mobile/passkey-login-fallback.png)

A fallback login is your safety net. It ensures that if passkey authentication cannot proceed for any reason (e.g., an unexpected error, no passkey available, or a failed ceremony), the user is seamlessly directed to your traditional login screen (e.g., using email and password). This mechanism provides exceptional robustness, guaranteeing that your users always have a path to authenticate.

## Step 3: Passkey Management

Providing users with a way to manage their passkeys is a critical part of the experience. Your application should offer a secure, authenticated area (like a profile or settings page) where users can list, delete, and add new passkeys.

The **Corbado iOS SDK** provides all the necessary methods to build this functionality into your app. The complete passkey management flow is also illustrated in detail in our [Passkey Management Flow documentation](/corbado-connect/flows/passkey-management).

### Implementation Overview

The passkey management process consists of a series of coordinated interactions between your iOS native app, your backend, and Corbado's APIs. Here's a high-level overview of the flow for listing passkeys. The flows for deleting and creating a new passkey are similar.

```mermaid
sequenceDiagram
    autonumber
    participant App as Your<br/>iOS Native App
    participant Backend as Your<br/>Backend
    participant FAPI as Corbado<br />Frontend API
    participant BAPI as Corbado<br />Backend API

    Note over App: Corbado iOS SDK
    App->>+Backend: POST /auth/createConnectToken
    Backend->>Backend: Verify user session
    Backend->>+BAPI: POST /v2/connectTokens
    BAPI-->>-Backend: Return ConnectToken
    Backend-->>-App: Return ConnectToken

    App->>+FAPI: Request passkey list<br/>(uses ConnectToken)
    Note over App: Corbado iOS SDK<br />handles passkey list
    FAPI-->>-App: Return success
```

In the following sections, we will explain each step in detail.

### App Integration

All passkey management operations are security-sensitive and must be authorized. For this purpose, the **Corbado iOS SDK** uses a short-lived `connectToken` that you generate on your backend for an authenticated user. This token proves to Corbado's APIs that the user performing the action has a valid session with your system.

To provide this token to the **Corbado iOS SDK** in a secure and timely manner, all management methods require a `connectTokenProvider`. This is a closure that the SDK calls just before executing an operation to get a fresh `connectToken`. You can reuse the `AppBackend` helper class for this, simply ensuring you request a token of type `manage`.

#### List Passkeys

To build a passkey management screen, you need to know two things: what passkeys the user currently has, and whether they are allowed to add a new one. The `isManageAppendAllowed()` method from the **Corbado iOS SDK** conveniently provides both pieces of information in a single call.

This eligibility check is governed by your project's settings for [Gradual Rollout](/corbado-connect/features/gradual-rollout) and [Passkey Intelligence](/corbado-connect/features/passkey-intelligence). The method returns the list of existing passkeys along with a status indicating if the "Add new passkey" button should be displayed.

```swift
// This single method both fetches the list of current passkeys and checks
// if the user is eligible to add a new one.
let nextStep = await corbado.isManageAppendAllowed(connectTokenProvider: {
    // The SDK needs a connectToken of type 'PasskeyList' to authorize this action.
    return try await AppBackend.getConnectToken(connectTokenType: .PasskeyList, sessionId: "your-user-session-id")
})

switch nextStep {
case .allowed(let passkeys):
    // Success. The user is allowed to add a new passkey.
    // Update your UI state with the `passkeys` array to display them.
    // Your UI should also show an "Add new passkey" button.

case .notAllowed(let passkeys):
    // Success, but with a condition. The user is *not* allowed to add a new passkey.
    // Update your UI state with the `passkeys` array to display them.
    // The "Add new passkey" button should be hidden.

case .error(let error):
    // An error occurred during the process.
    // Handle the error, for example by showing an alert to the user.
}
```

#### Delete Passkey

To allow a user to delete a passkey, you first need to identify which passkey they wish to remove. Typically, this is done by having the user select one from the list you populated in the previous step. Once you have the passkey's ID, you call the `deletePasskey()` method from the **Corbado iOS SDK**.

This operation also requires authorization, so you must provide the same `connectTokenProvider` as before to generate a fresh `connectToken` of type `PasskeyDelete`.

```swift
// This assumes 'passkey' is the PasskeyInfo object selected by the user from your UI list.
let status = await corbado.deletePasskey(passkeyId: passkey.id) { _ in
    // Provide a connectToken of type 'PasskeyDelete' to authorize the deletion.
    return try await AppBackend.getConnectToken(connectTokenType: .PasskeyDelete, sessionId: "your-user-session-id")
}

switch status {
case .done(let passkeys):
    // Deletion was successful.
    // The SDK conveniently returns the updated list of passkeys.
    // You should refresh your UI with this new list.
    
case .error(let error):
    // An error occurred during the deletion process.
    // You should handle the specific error and show an appropriate message to the user.
    
default:
    // A fallback for any other unhandled cases.
    // You could show a generic error message here.
}
```

#### Create Passkey

If the user is allowed to add a new passkey (as determined by the `isManageAppendAllowed()` method), your UI should present an "Add new passkey" button. When the user taps this button, you call the `completePasskeyListAppend()` method from the **Corbado iOS SDK**.

This function initiates the native iOS passkey creation ceremony. It requires a `connectTokenProvider` to authorize the action, but for this operation, you must request a `connectToken` of type `PasskeyAppend` from your backend.

```swift
// This would be called when the user taps the "Add new passkey" button in your UI.
let status = await corbado.completePasskeyListAppend { _ in
    // Provide a connectToken of type 'PasskeyAppend' to authorize the creation.
    return try await AppBackend.getConnectToken(connectTokenType: .PasskeyAppend, sessionId: "your-user-session-id")
}

switch status {
case .done(let passkeys):
    // Success! The new passkey was created.
    // The SDK returns the updated list of passkeys, including the new one.
    // You should refresh your UI with this new list.
    
case .passkeyOperationCancelled:
    // The user manually cancelled the native iOS prompt.
    // No action is typically needed, but you could show a transient message.
    
case .error(_):
    // An unexpected error occurred during the process.
    // Display a clear error message to the user.
    
case .passkeyOperationExcludeCredentialsMatch:
    // A passkey from this device already exists for the user.
    // This is not an error. Inform the user gracefully.
}
```